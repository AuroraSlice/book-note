内核将进程列表放在task list的双向循环列表当中，结构体为task_struct,linux使用slab分配task_struct   current宏指向当前运行的进程

进程家族树 parent指针 children指针

进程的创建：1.fork()在新的地址空间创建新进程,操作是复制当前进程出一个子进程，区别只在PID等。
           2.exec()负责将可执行文件载入地址空间并进行运行
           
           fork()使用了写时拷贝的方式，也就是只在需要写入数据时进行拷贝，否则是和其父进程共享数据，读相同内存。fork()实际做的只是复制
           父进程的页表和创建唯一的进程号PID
           
           linux中的线程其实只是指定了共享资源的几个进程，对于每个线程来讲都会维护一个task_struct结构。线程是linux实现资源共享的重要手段
           
进程的销毁：一个进程终结时，内核需要告知其父进程，一般通过do_exit()来结束进程
           1.task_struct中标志成员设置为PF_EXITING
           2.调用del_timer_sync删除定时器，确保没有定时器任务在排队，也没有定时器任务在执行
           3.若记账功能开启，则调用acct_update_intergrals输出记账信息
           4.调用exit_mm函数释放进程占用的mm_struct,若此内存没有被其他进程共享使用，则释放
           5.调用sem_exit()
           6.调用exit_files()和exit_fs()，递减文件引用计数和文件描述符，若引用计数为0则释放
           7.置位task_struct中的exit_code退出代码号
           8.调用exit_notify向父进程发送信号，给子进程找养父
           9.do_exit()调用schedule进程切换到新进程。
           
孤儿进程

IO消耗型进程、处理器消耗进程（例如大量数学计算）

1.进程优先级：ps-el查看进程的nice值，值愈大优先级越低
2.时间片：进程被抢占前能持续运行的时间

完全公平调度（CFS）

系统调用在用户层和内核层之间增加了一个中间层，为用户层访问硬件层提供了抽象接口，系统调用是用户层访问内核层的合法手段，目前编程一般都使用
API或者C库来执行系统调用，如printf最终会执行内核中的write()系统调用。所有系统调用都存储在sys_call_table中，每个系统调用都对应一个系统调用号

中断上下文：中断上文用于处理时间要求严格的部分，例如中断应答、复位硬件，以便尽快恢复中断接收下一次中断，避免中断被禁止时间过长导致交互效果差，而中断下半部则
处理可以稍微延迟的操作。
中断上下文与进程不同，current此时指向的是被中断的进程（被打断的那个进程），中断上下文不可睡眠，否则没有人重新唤醒，因为打断了其他程序，因此中断应该快速高效地执行完成
中断也有可能打断其他中断的处理程序

软中断是编译时静态分配的，不能被创建或注销，linux中使用32大小的数组存储softirq_action表示软中断，即最大32个软中断，软中断之间不会互相抢占，软中断只会被硬中断抢占。
软中断是给时间严格的下半部使用，如内核的定时器。tasklet是利用软中断实现的一种下半部机制，tasklet比软中断使用更方便简单，锁机制要求叶少，因此软中断使用较少，大多使用tasklet

编写中断处理程序

辨别共享数据和临界区代码并在写代码的时候即进行加锁保护是最重要的，如果在程序写好后再加锁往往不尽人意。加锁的准则是，给共享数据加锁二不是给代码加锁。      

死锁产生的条件：要有一个或多个执行线程和一个或多个资源，每个线程都在等待其中一个资源，但是所有资源都已经被占用了。
避免死锁的方法：1.按顺序加锁，这样避免嵌套锁时拥抱类型的死锁
               2.防止发生饥饿。即试问代码的运行可能性
               3.不要重复请求同一个锁
               4.锁的使用尽量简洁
第一个条件最重要，假设使用多个锁，则在各个函数之中都采用相同的顺序请求锁，这样就可以避免死锁。

原子操作？？？

1.自旋锁：当一个线程持有了临界区的自旋锁时，另一个线程到达临界区就会不断旋转-等待锁可用，会一直进行查询锁是否可用，较为耗费CPU
2.信号量：信号量是第二种锁机制，是一种睡眠锁，相比于自旋锁，信号量可以让线程进入睡眠状态，而不是进行自我旋转，耗费CPU较少。信号量会将任务放入到等待队列中，信号量释放后会唤醒任务。
  计数信号量和二值信号量

中断处理上尽量不要使用自旋锁，否则需要禁止中断，否则会导致双重求锁

读写自旋锁
